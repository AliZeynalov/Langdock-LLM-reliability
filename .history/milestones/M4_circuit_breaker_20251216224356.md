# M4: Circuit Breaker + Failover

**Goal:** Skip broken providers and failover to healthy ones.

**Time:** 3-4 hours  
**Output:** Circuit breaker prevents calling broken provider, router handles failover

---

## What We're Building

```
                    ┌─────────────────┐
                    │     Router      │
                    │ (picks provider)│
                    └────────┬────────┘
                             │
           ┌─────────────────┴─────────────────┐
           │                                   │
    ┌──────▼──────┐                     ┌──────▼──────┐
    │   Circuit   │                     │   Circuit   │
    │   Breaker   │                     │   Breaker   │
    │  (OpenAI)   │                     │ (Anthropic) │
    └──────┬──────┘                     └──────┬──────┘
           │                                   │
    ┌──────▼──────┐                     ┌──────▼──────┐
    │   OpenAI    │                     │  Anthropic  │
    │   :8001     │                     │   :8002     │
    └─────────────┘                     └─────────────┘
```

---

## Circuit Breaker States (Simplified)

We use 2 states only (no half-open for simplicity):

```
┌──────────┐         3 consecutive      ┌──────────┐
│  CLOSED  │ ─────── failures ────────▶ │   OPEN   │
│ (healthy)│                            │ (broken) │
└──────────┘ ◀──────── 30 seconds ───── └──────────┘
                     auto-reset
```

| State | Behavior |
|-------|----------|
| **CLOSED** | Normal - allow requests, track failures |
| **OPEN** | Broken - reject requests immediately, skip to next provider |

---

## Key Concepts

### 1. Circuit Breaker

Tracks consecutive failures for a provider. Opens after threshold reached.

```go
// internal/provider/circuit_breaker.go

type CircuitBreaker struct {
    name              string
    state             string        // "closed" or "open"
    consecutiveFails  int
    failureThreshold  int           // Opens after this many failures
    resetTimeout      time.Duration // Auto-close after this duration
    lastFailure       time.Time
    mu                sync.Mutex
}

func NewCircuitBreaker(name string) *CircuitBreaker {
    return &CircuitBreaker{
        name:             name,
        state:            "closed",
        failureThreshold: 3,
        resetTimeout:     30 * time.Second,
    }
}

// CanExecute checks if request should proceed
func (cb *CircuitBreaker) CanExecute() bool {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    if cb.state == "closed" {
        return true
    }
    
    // Check if reset timeout has passed
    if time.Since(cb.lastFailure) > cb.resetTimeout {
        cb.state = "closed"
        cb.consecutiveFails = 0
        log.WithField("provider", cb.name).Info("Circuit breaker reset to closed")
        return true
    }
    
    return false
}

// RecordSuccess resets failure count
func (cb *CircuitBreaker) RecordSuccess() {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    cb.consecutiveFails = 0
}

// RecordFailure increments failure count, may open circuit
func (cb *CircuitBreaker) RecordFailure() {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    
    cb.consecutiveFails++
    cb.lastFailure = time.Now()
    
    if cb.consecutiveFails >= cb.failureThreshold {
        cb.state = "open"
        log.WithFields(log.Fields{
            "provider": cb.name,
            "failures": cb.consecutiveFails,
        }).Warn("Circuit breaker opened")
    }
}

// IsOpen returns true if circuit is open
func (cb *CircuitBreaker) IsOpen() bool {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    return cb.state == "open"
}

// State returns current state for metrics
func (cb *CircuitBreaker) State() string {
    cb.mu.Lock()
    defer cb.mu.Unlock()
    return cb.state
}
```

### 2. Router (Provider Selection + Failover)

Selects provider and handles failover:

```go
// internal/provider/router.go

type Provider struct {
    Name    string
    URL     string
    Circuit *CircuitBreaker
}

type Router struct {
    providers []*Provider
}

func NewRouter(openAIURL, anthropicURL string) *Router {
    return &Router{
        providers: []*Provider{
            {
                Name:    "openai",
                URL:     openAIURL,
                Circuit: NewCircuitBreaker("openai"),
            },
            {
                Name:    "anthropic",
                URL:     anthropicURL,
                Circuit: NewCircuitBreaker("anthropic"),
            },
        },
    }
}

// GetHealthyProvider returns next available provider
func (r *Router) GetHealthyProvider() (*Provider, error) {
    for _, p := range r.providers {
        if p.Circuit.CanExecute() {
            return p, nil
        }
    }
    return nil, fmt.Errorf("all providers unavailable")
}

// GetNextProvider returns the next provider after the given one (for failover)
func (r *Router) GetNextProvider(currentName string) (*Provider, error) {
    foundCurrent := false
    for _, p := range r.providers {
        if p.Name == currentName {
            foundCurrent = true
            continue
        }
        if foundCurrent && p.Circuit.CanExecute() {
            return p, nil
        }
    }
    
    // Wrap around - check providers before current
    for _, p := range r.providers {
        if p.Name == currentName {
            break
        }
        if p.Circuit.CanExecute() {
            return p, nil
        }
    }
    
    return nil, fmt.Errorf("no alternative providers available")
}
```

### 3. Updated Client with Router

```go
// internal/provider/client.go

type Client struct {
    httpClient  *http.Client
    router      *Router
    retryConfig RetryConfig
}

func NewClient(config Config) *Client {
    return &Client{
        httpClient: &http.Client{
            Timeout: config.Timeout,
        },
        router: NewRouter(config.OpenAIURL, config.AnthropicURL),
        retryConfig: RetryConfig{
            MaxAttempts: 3,
            BaseDelay:   1 * time.Second,
            MaxDelay:    10 * time.Second,
        },
    }
}

func (c *Client) Call(ctx context.Context, req models.Request) (*ProviderResponse, error) {
    requestID := ctx.Value("request_id").(string)
    
    // Get initial provider
    provider, err := c.router.GetHealthyProvider()
    if err != nil {
        return nil, fmt.Errorf("no healthy providers: %w", err)
    }
    
    var lastErr error
    totalAttempts := 0
    
    for provider != nil {
        log.WithFields(log.Fields{
            "request_id": requestID,
            "provider":   provider.Name,
            "event":      "selected",
        }).Info("Provider selected")
        
        // Try this provider with retries
        response, err := c.callWithRetry(ctx, req, provider)
        totalAttempts += response.Attempts
        
        if err == nil {
            response.Attempts = totalAttempts
            return response, nil
        }
        
        lastErr = err
        
        // Check if we should failover
        var reqErr *RequestError
        if errors.As(err, &reqErr) && reqErr.Failover {
            log.WithFields(log.Fields{
                "request_id":    requestID,
                "from_provider": provider.Name,
                "event":         "failover",
            }).Info("Triggering failover")
            
            // Get next provider
            nextProvider, err := c.router.GetNextProvider(provider.Name)
            if err != nil {
                log.WithField("request_id", requestID).Warn("No failover provider available")
                break
            }
            
            log.WithFields(log.Fields{
                "request_id":  requestID,
                "to_provider": nextProvider.Name,
                "event":       "failover",
            }).Info("Failing over to next provider")
            
            provider = nextProvider
            continue
        }
        
        // Non-failover error - stop trying
        break
    }
    
    return nil, fmt.Errorf("all attempts failed: %w", lastErr)
}

func (c *Client) callWithRetry(ctx context.Context, req models.Request, provider *Provider) (*ProviderResponse, error) {
    requestID := ctx.Value("request_id").(string)
    
    for attempt := 1; attempt <= c.retryConfig.MaxAttempts; attempt++ {
        log.WithFields(log.Fields{
            "request_id": requestID,
            "provider":   provider.Name,
            "attempt":    attempt,
            "event":      "attempt",
        }).Info("Attempting request")
        
        response, err := c.doRequest(ctx, req, provider.URL)
        
        if err == nil {
            provider.Circuit.RecordSuccess()
            response.Provider = provider.Name
            response.Attempts = attempt
            return response, nil
        }
        
        // Record failure
        provider.Circuit.RecordFailure()
        
        // Check if error is retryable
        var reqErr *RequestError
        if errors.As(err, &reqErr) {
            if reqErr.Failover {
                // 429 - don't retry, trigger failover
                return &ProviderResponse{Attempts: attempt}, err
            }
            
            if !reqErr.Retryable {
                // Not retryable - return error
                return &ProviderResponse{Attempts: attempt}, err
            }
        }
        
        // Wait before retry (unless last attempt)
        if attempt < c.retryConfig.MaxAttempts {
            wait := c.calculateBackoff(attempt)
            log.WithFields(log.Fields{
                "request_id": requestID,
                "wait_ms":    wait.Milliseconds(),
                "event":      "backoff",
            }).Info("Waiting before retry")
            
            select {
            case <-time.After(wait):
            case <-ctx.Done():
                return &ProviderResponse{Attempts: attempt}, ctx.Err()
            }
        }
    }
    
    return &ProviderResponse{Attempts: c.retryConfig.MaxAttempts}, 
           fmt.Errorf("exhausted %d attempts", c.retryConfig.MaxAttempts)
}
```

---

## Testing

### Setup: Two Mock Providers

```bash
# Terminal 1: Mock OpenAI on :8001
go run cmd/mock-provider/main.go -port 8001

# Terminal 2: Mock Anthropic on :8002
go run cmd/mock-provider/main.go -port 8002

# Terminal 3: Gateway
go run cmd/server/main.go
```

### Test 1: Circuit Breaker Opens

```bash
# Send requests that fail with 500
for i in {1..4}; do
  curl -X POST "http://localhost:8080/v1/chat/completions" \
    -H "Content-Type: application/json" \
    -d '{"model": "gpt-4", "messages": [{"role": "user", "content": "Hello"}]}'
  echo ""
done

# Configure mock to return 500:
# Request goes to mock: localhost:8001/v1/chat/completions?fail=500
```

**Expected:** After 3 failures, circuit opens, 4th request goes to anthropic.

### Test 2: Rate Limit Failover

```bash
# Configure OpenAI mock to return 429
curl -X POST "http://localhost:8080/v1/chat/completions" ...

# Logs should show:
# selected provider=openai
# received 429
# failover to anthropic
# selected provider=anthropic
# success
```

### Test 3: All Providers Down

```bash
# Configure both mocks to return 500
# After circuit breaks on both:
curl -X POST "http://localhost:8080/v1/chat/completions" ...

# Should return:
# {"error": "no healthy providers available"}
```

---

## Expected Logs (Circuit Breaker + Failover)

```
INFO  request_id=req_a1b2 event=selected provider=openai
INFO  request_id=req_a1b2 event=attempt provider=openai attempt=1
WARN  request_id=req_a1b2 event=failed error="status 500"
INFO  request_id=req_a1b2 event=backoff wait_ms=1000
INFO  request_id=req_a1b2 event=attempt provider=openai attempt=2
WARN  request_id=req_a1b2 event=failed error="status 500"
INFO  request_id=req_a1b2 event=backoff wait_ms=2000
INFO  request_id=req_a1b2 event=attempt provider=openai attempt=3
WARN  request_id=req_a1b2 event=failed error="status 500"
WARN  provider=openai failures=3 Circuit breaker opened
INFO  request_id=req_a1b2 event=failover from_provider=openai
INFO  request_id=req_a1b2 event=failover to_provider=anthropic
INFO  request_id=req_a1b2 event=selected provider=anthropic
INFO  request_id=req_a1b2 event=attempt provider=anthropic attempt=1
INFO  request_id=req_a1b2 event=success provider=anthropic
```

---

## Definition of Done

- [ ] CircuitBreaker tracks consecutive failures per provider
- [ ] Circuit opens after 3 failures
- [ ] Circuit auto-resets after 30 seconds
- [ ] Router returns healthy provider
- [ ] Router handles failover to next provider
- [ ] 429 triggers immediate failover (no retry)
- [ ] 5xx triggers retry then failover
- [ ] Logs show circuit state changes
- [ ] Logs show failover events
- [ ] Returns error when all providers unavailable

