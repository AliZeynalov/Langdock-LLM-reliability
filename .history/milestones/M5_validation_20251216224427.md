# M5: Request Validation

**Goal:** Reject invalid requests before making expensive API calls.

**Time:** 2-3 hours  
**Output:** Validation fails fast with clear error messages

---

## What We're Building

```
Request arrives
      │
      ▼
┌─────────────┐
│  Validator  │ ─── Invalid ──▶ 400 Bad Request (< 10ms)
│             │                  No provider call!
└──────┬──────┘
       │ Valid
       ▼
   Continue to provider
```

---

## What We Validate

| Field | Rule | Error |
|-------|------|-------|
| `model` | Required, non-empty | "model is required" |
| `messages` | Required, non-empty array | "messages is required" |
| `messages[].role` | Must be "user", "assistant", or "system" | "invalid role: xyz" |
| `messages[].content` | Required, non-empty | "message content is required" |
| `temperature` | 0.0 to 2.0 (if provided) | "temperature must be between 0 and 2" |
| `max_tokens` | > 0 (if provided) | "max_tokens must be positive" |

---

## Implementation

### Validator Package

```go
// internal/validator/validator.go
package validator

import (
    "fmt"
    "strings"
    
    "your-module/internal/models"
)

// ValidationError contains validation failure details
type ValidationError struct {
    Field   string `json:"field"`
    Message string `json:"message"`
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("%s: %s", e.Field, e.Message)
}

// ValidationErrors holds multiple validation errors
type ValidationErrors struct {
    Errors []ValidationError `json:"errors"`
}

func (e *ValidationErrors) Error() string {
    var msgs []string
    for _, err := range e.Errors {
        msgs = append(msgs, err.Error())
    }
    return strings.Join(msgs, "; ")
}

func (e *ValidationErrors) Add(field, message string) {
    e.Errors = append(e.Errors, ValidationError{
        Field:   field,
        Message: message,
    })
}

func (e *ValidationErrors) HasErrors() bool {
    return len(e.Errors) > 0
}

// ValidateRequest validates a chat completion request
func ValidateRequest(req *models.Request) error {
    errs := &ValidationErrors{}
    
    // Model is required
    if req.Model == "" {
        errs.Add("model", "model is required")
    }
    
    // Messages is required and non-empty
    if len(req.Messages) == 0 {
        errs.Add("messages", "messages is required and cannot be empty")
    } else {
        // Validate each message
        for i, msg := range req.Messages {
            validateMessage(msg, i, errs)
        }
    }
    
    // Temperature range (if provided)
    if req.Temperature < 0 || req.Temperature > 2 {
        // Note: 0 is valid, we only check if explicitly set outside range
        if req.Temperature != 0 || containsTemperature(req) {
            if req.Temperature < 0 || req.Temperature > 2 {
                errs.Add("temperature", "temperature must be between 0 and 2")
            }
        }
    }
    
    // MaxTokens must be positive (if provided)
    if req.MaxTokens < 0 {
        errs.Add("max_tokens", "max_tokens must be positive")
    }
    
    if errs.HasErrors() {
        return errs
    }
    
    return nil
}

func validateMessage(msg models.Message, index int, errs *ValidationErrors) {
    field := fmt.Sprintf("messages[%d]", index)
    
    // Role is required and must be valid
    validRoles := map[string]bool{
        "user":      true,
        "assistant": true,
        "system":    true,
    }
    
    if msg.Role == "" {
        errs.Add(field+".role", "role is required")
    } else if !validRoles[msg.Role] {
        errs.Add(field+".role", fmt.Sprintf("invalid role '%s', must be user, assistant, or system", msg.Role))
    }
    
    // Content is required
    if msg.Content == "" {
        errs.Add(field+".content", "content is required")
    }
}

// Helper to check if temperature was explicitly set
// (since 0 is both default and valid value)
func containsTemperature(req *models.Request) bool {
    // In real implementation, you'd check if the JSON contained this field
    // For simplicity, we assume temperature of exactly 0 wasn't explicitly set
    return req.Temperature != 0
}
```

### Using Validator in Handler

```go
// internal/gateway/handler.go

import (
    "your-module/internal/validator"
)

func (h *Handler) ChatCompletion(c *gin.Context) {
    requestID := c.GetString("request_id")
    
    // Parse request body
    var req models.Request
    if err := c.ShouldBindJSON(&req); err != nil {
        log.WithFields(log.Fields{
            "request_id": requestID,
            "error":      err.Error(),
            "event":      "parse_error",
        }).Warn("Failed to parse request body")
        
        c.JSON(http.StatusBadRequest, gin.H{
            "error": gin.H{
                "type":    "invalid_request",
                "message": "Failed to parse request body: " + err.Error(),
            },
        })
        return
    }
    
    // Validate request
    if err := validator.ValidateRequest(&req); err != nil {
        log.WithFields(log.Fields{
            "request_id": requestID,
            "error":      err.Error(),
            "event":      "validation_failed",
        }).Warn("Request validation failed")
        
        // Return detailed validation errors
        if validErrs, ok := err.(*validator.ValidationErrors); ok {
            c.JSON(http.StatusBadRequest, gin.H{
                "error": gin.H{
                    "type":    "validation_error",
                    "message": "Request validation failed",
                    "details": validErrs.Errors,
                },
            })
            return
        }
        
        c.JSON(http.StatusBadRequest, gin.H{
            "error": gin.H{
                "type":    "validation_error",
                "message": err.Error(),
            },
        })
        return
    }
    
    log.WithFields(log.Fields{
        "request_id": requestID,
        "model":      req.Model,
        "event":      "validated",
    }).Info("Request validated")
    
    // Continue with provider call...
}
```

---

## Error Response Format

```json
{
  "error": {
    "type": "validation_error",
    "message": "Request validation failed",
    "details": [
      {
        "field": "model",
        "message": "model is required"
      },
      {
        "field": "messages",
        "message": "messages is required and cannot be empty"
      }
    ]
  }
}
```

---

## Testing

### Test 1: Missing Model

```bash
curl -X POST http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"messages": [{"role": "user", "content": "Hello"}]}'

# Expected: 400 with "model is required"
```

### Test 2: Empty Messages

```bash
curl -X POST http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"model": "gpt-4", "messages": []}'

# Expected: 400 with "messages cannot be empty"
```

### Test 3: Invalid Role

```bash
curl -X POST http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"model": "gpt-4", "messages": [{"role": "invalid", "content": "Hello"}]}'

# Expected: 400 with "invalid role 'invalid'"
```

### Test 4: Invalid Temperature

```bash
curl -X POST http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"model": "gpt-4", "messages": [{"role": "user", "content": "Hello"}], "temperature": 5.0}'

# Expected: 400 with "temperature must be between 0 and 2"
```

### Test 5: Multiple Errors

```bash
curl -X POST http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"messages": [{"role": "invalid", "content": ""}]}'

# Expected: 400 with multiple errors:
# - model is required
# - invalid role 'invalid'
# - content is required
```

### Test 6: Valid Request (Sanity Check)

```bash
curl -X POST http://localhost:8080/v1/chat/completions \
  -H "Content-Type: application/json" \
  -d '{"model": "gpt-4", "messages": [{"role": "user", "content": "Hello"}]}'

# Expected: 200, normal response
```

---

## Expected Logs

```
# Invalid request
INFO  request_id=req_abc123 event=started method=POST path=/v1/chat/completions
WARN  request_id=req_abc123 event=validation_failed error="model: model is required"
INFO  request_id=req_abc123 event=completed status=400 latency_ms=2

# Valid request
INFO  request_id=req_def456 event=started method=POST path=/v1/chat/completions
INFO  request_id=req_def456 event=validated model=gpt-4
INFO  request_id=req_def456 event=attempt provider=openai attempt=1
INFO  request_id=req_def456 event=success
INFO  request_id=req_def456 event=completed status=200 latency_ms=150
```

---

## Definition of Done

- [ ] Model required validation
- [ ] Messages required validation
- [ ] Message role validation (user/assistant/system)
- [ ] Message content required validation
- [ ] Temperature range validation (0-2)
- [ ] MaxTokens positive validation
- [ ] Returns 400 with detailed error messages
- [ ] No provider call made on validation failure
- [ ] Response time < 10ms for validation errors
- [ ] Logs show validation_failed event

